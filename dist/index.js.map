{"version":3,"file":"index.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../index.js"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = (function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tvalue = Promise.resolve(value);\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn Promise.resolve(value).then(_empty);\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar reject = _settle.bind(null, pact, 2);\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n","const fse = require(\"fs-extra\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst name = \"webpack-copy-noloop-plugin\";\n\nconst isDir = location => fs.statSync(location).isDirectory();\nconst gatherFiles = location => pattern => {\n  return fs.readdirSync(location).reduce((last, file) => {\n    const fileInAbs = path.join(location, \"/\", file);\n    if (isDir(fileInAbs)) {\n      last.concat(gatherFiles(path.join(location, \"/\", file))(pattern));\n    } else {\n      if (pattern.test(fileInAbs)) {\n        last.push(fileInAbs);\n      }\n    }\n    return last;\n  }, []);\n};\n\n/**\n * if copy file from directory\n * generate proper dest path\n * @param {string} dirFromPath\n * @param {string} dirToPath\n * @returns {function(string, boolean=)}\n */\nconst getDestPath = (dirFromPath, dirToPath) => (\n  fileFromPath,\n  flatten = false\n) => {\n  const relativePath = flatten\n    ? path.basename(fileFromPath)\n    : path.relative(dirFromPath, fileFromPath);\n  return path.join(dirToPath, \"/\", relativePath);\n};\n\n/**\n * @typedef {object} CopyItem\n * @property {string} from\n * @property {string} to\n * @property {function(string, string)=} filter\n * @property {regexp=} pattern\n * @property {boolean=} flatten\n */\n\nclass CopyNoLoopPlugin {\n  /**\n   * @param {object} options\n   * @param {CopyItem[]} options.list\n   * @param {string=} options.root root directory\n   * @param {boolean=} [options.move=false] whether to move or not\n   * @param {function|number=} [options.waitFor=() => Promise.resolve()]\n   */\n  constructor(options) {\n    this.options = options;\n  }\n\n  apply(compiler) {\n    compiler.hooks.done.tap(\"CopyNoLoopPlugin\", async () => {\n      const {\n        list,\n        root,\n        move = false,\n        waitFor = () => Promise.resolve()\n      } = this.options;\n      const action = move ? \"moveSync\" : \"copySync\";\n      if (!Array.isArray(list)) return;\n      let listMut = list.slice();\n      if (root) {\n        // check for absolute\n        if (!path.isAbsolute(root)) {\n          throw new Error(`[${name}]: root needs to be an absolute path!`);\n        }\n        listMut = listMut.map(item => {\n          return {\n            ...item,\n            from: path.resolve(root, item.from),\n            to: path.resolve(root, item.to)\n          };\n        });\n      }\n      try {\n        switch (typeof waitFor) {\n          case \"function\":\n            await waitFor();\n            break;\n          case \"number\":\n            await new Promise(resolve => setTimeout(resolve, waitFor));\n            break;\n          default:\n            break;\n        }\n      } catch (e) {\n        console.log(`[${name}]: Err occurred when trying to execute waitFor`);\n        console.log(e);\n        process.exit(1);\n      }\n\n      listMut.forEach(item => {\n        const {\n          from,\n          to,\n          filter = () => true,\n          pattern,\n          flatten = false\n        } = item;\n        if (isDir(from) && pattern) {\n          const files = gatherFiles(from)(pattern);\n          files.forEach(file => {\n            const dest = getDestPath(from, to)(file, flatten);\n            fse[action](file, dest, { filter, overwrite: true });\n          });\n        } else {\n          fse[action](from, to, {\n            filter,\n            overwrite: true\n          });\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = CopyNoLoopPlugin;\n"],"names":["const","fse","require","fs","path","name","isDir","location","statSync","isDirectory","gatherFiles","pattern","readdirSync","reduce","last","file","fileInAbs","join","concat","test","push","getDestPath","dirFromPath","dirToPath","fileFromPath","flatten","relativePath","basename","relative","CopyNoLoopPlugin","constructor","options","apply","compiler","hooks","done","tap","listMut","forEach","item","to","from","files","dest","action","filter","list","root","Promise","resolve","move","Array","isArray","slice","isAbsolute","Error","map","waitFor","setTimeout","e","log","console","process","exit","module","exports"],"mappings":"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"}